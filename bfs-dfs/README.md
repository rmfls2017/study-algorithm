# BFS / DFS

그래프 탐색의 두 가지 기본 방법

## 그래프란?

노드(정점)와 간선으로 이루어진 자료구조. 트리도 그래프의 일종.

```
트리: 방향 있음, 순환 없음, 루트 있음
그래프: 아무 노드끼리 연결 가능, 순환 가능
```

## BFS vs DFS

| | BFS (너비 우선) | DFS (깊이 우선) |
|---|----------------|----------------|
| 자료구조 | Queue (선입선출) | Stack (후입선출) |
| 탐색 방식 | 가까운 것부터 | 끝까지 갔다가 돌아옴 |
| 키워드 | 최단, 최소 | 모든, 개수, 연결 |

## 탐색 순서 비교

```
    A --- B
    |     |
    C --- D --- E

BFS: A → B → C → D → E (가까운 것부터)
DFS: A → C → D → E → B (한 방향으로 끝까지)
```

## BFS 동작 원리

```
1. 시작점을 Queue에 넣음
2. Queue가 빌 때까지 반복:
   - 하나 꺼냄
   - 방문 안 한 인접 노드를 Queue에 추가
3. 이미 방문한 노드는 건너뜀 (무한 루프 방지)
```

## DFS 동작 원리

```
1. 시작점을 Stack에 넣음 (또는 재귀 시작)
2. Stack이 빌 때까지 반복:
   - 하나 꺼냄
   - 방문 안 한 인접 노드를 Stack에 추가
3. 이미 방문한 노드는 건너뜀
```

## 언제 무엇을 쓸까?

### BFS를 쓰는 경우

- **최단 거리**: 미로에서 출구까지 최단 경로
- **최소 횟수**: 목표까지 최소 연산 횟수
- **레벨별 탐색**: 트리에서 같은 깊이 노드 묶기

### DFS를 쓰는 경우

- **연결 요소 개수**: 섬의 개수 세기
- **모든 경로 탐색**: A에서 B로 가는 모든 경로
- **경우의 수**: 가능한 모든 조합

## 격자(Grid)에서의 BFS 패턴

```java
int[] dx = {-1, 1, 0, 0};  // 상, 하, 좌, 우
int[] dy = {0, 0, -1, 1};

Queue<int[]> queue = new LinkedList<>();
queue.offer(new int[]{startX, startY});

while (!queue.isEmpty()) {
    int[] current = queue.poll();
    int x = current[0];
    int y = current[1];
    
    for (int d = 0; d < 4; d++) {
        int nx = x + dx[d];
        int ny = y + dy[d];
        
        if (범위 안 && 방문 가능 && 아직 방문 안 함) {
            queue.offer(new int[]{nx, ny});
        }
    }
}
```

## 문제 목록

- [994. Rotting Oranges](./994-rotting-oranges/) - 다중 시작점 BFS
