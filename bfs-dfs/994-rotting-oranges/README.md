# LeetCode 994: Rotting Oranges

## 문제

m x n 격자판에 오렌지가 있음:
- 0: 빈 칸
- 1: 신선한 오렌지
- 2: 썩은 오렌지

매 분마다 썩은 오렌지에 인접한 (상하좌우) 신선한 오렌지가 썩음.

모든 오렌지가 썩는 데 걸리는 **최소 시간** 반환. 불가능하면 -1.

```
예시:
[2, 1, 1]
[1, 1, 0]
[0, 1, 1]

분 0: (0,0) 썩음
분 1: (0,1), (1,0) 썩음
분 2: (0,2), (1,1) 썩음
분 3: (2,1) 썩음
분 4: (2,2) 썩음

답: 4
```

---

## 풀이 과정

### 왜 BFS인가?

"최소 시간"을 구해야 함 → BFS!

BFS는 가까운 것부터 처리하니까, 모든 오렌지가 썩었을 때가 최소 시간.

### 미로 문제와 비교

| | 미로 | 오렌지 |
|---|------|--------|
| 시작점 | 1개 (S) | **여러 개** (모든 썩은 오렌지) |
| 종료 조건 | E에 도착 | 모든 신선한 오렌지 썩음 |
| 실패 조건 | E 못 찾음 | 신선한 오렌지 남음 |

### 핵심: 다중 시작점 BFS

썩은 오렌지가 여러 개면 **동시에** 퍼져나감.

```
처음: 썩은 오렌지 3개 → Queue에 3개 다 넣음
1분 후: 3개 주변이 동시에 썩음
2분 후: 새로 썩은 것들 주변이 동시에 썩음
...
```

### 분 단위 처리

```java
while (!queue.isEmpty()) {
    int size = queue.size();  // 현재 Queue 크기 저장
    
    for (int i = 0; i < size; i++) {
        // 이 for문 안은 모두 "같은 분"에 처리
    }
    
    minutes++;  // for문 끝나면 1분 경과
}
```

`size`를 미리 저장해서, 새로 추가된 건 다음 분에 처리.

### 방문 체크

별도 `visited` 배열 대신 **grid를 직접 수정** (1→2).

이미 2인 칸은 다시 처리 안 함.

---

## 코드

→ [Solution.java](./Solution.java)

---

## 복잡도

- 시간: O(m × n) - 각 칸을 최대 한 번 방문
- 공간: O(m × n) - Queue에 최대 모든 칸 저장

---

## 배운 점

1. **다중 시작점 BFS**
   - 여러 시작점을 Queue에 모두 넣고 시작
   - 동시에 퍼져나가는 효과

2. **분 단위 처리**
   - `size = queue.size()` 로 현재 레벨 크기 저장
   - for문으로 같은 레벨 한꺼번에 처리

3. **종료 조건**
   - `freshCount`로 남은 신선한 오렌지 추적
   - 0이 되면 성공, 남아있으면 -1

---

## 관련 문제

- 200: Number of Islands (섬 개수 - DFS/BFS)
- 542: 01 Matrix (최단 거리)
- 286: Walls and Gates (다중 시작점 BFS)
