# LeetCode 3453: Separate Squares I

## 문제

2D 평면에 정사각형들이 주어짐. `squares[i] = [x, y, l]`
- (x, y): 왼쪽 아래 좌표
- l: 변의 길이

**목표**: 수평선 Y를 그어서 위/아래 면적이 같아지는 최소 Y값 찾기

```
예시: squares = [[0,0,1], [2,2,1]]

    +---+
    | B |   (y=2, 면적 1)
    +---+
────────────  ← Y=1 (이 선 위아래로 면적 1씩)
+---+
| A |       (y=0, 면적 1)
+---+

정답: 1.0
```

---

## 풀이 과정

### 처음에 헷갈렸던 부분

"왜 x좌표는 안 쓰지?"

수평선은 **가로로** 긋는다. x가 1이든 100이든 상관없이 같은 높이면 똑같이 잘림.

```
     +--+        +--+
     |A |        |B |
  ═══|══|════════|══|═══  ← Y=2 수평선
     |  |        |  |
     +--+        +--+
    x=1         x=7

둘 다 Y=2에서 똑같이 잘림
```

### 핵심 관찰

Y를 0에서 위로 올리면:
- Y=0 → 아래 면적 = 0
- Y=1 → 아래 면적 = 좀 늘어남
- Y=2 → 아래 면적 = 더 늘어남
- ...

**Y가 올라갈수록 아래 면적은 단조 증가**

→ 정렬된 것과 마찬가지 → Binary Search 가능

### 각 정사각형에서 아래 면적 계산

정사각형이 y=2에서 시작, 변의 길이 l=3이면:

```
y
↑
5 | +-----+
4 | |     |
3 | |     |
2 | +-----+
```

- Y=1에서 자르면 → 0 (선이 정사각형 아래)
- Y=3에서 자르면 → 3 × (3-2) = 3
- Y=7에서 자르면 → 3 × 3 = 9 (전체)

공식:
```
Y < y       → 0
Y > y + l   → l × l
그 외        → l × (Y - y)
```

### Binary Search 적용

```
1. 총 면적 계산 → target = 총 면적 / 2
2. Y 범위: 최소 y ~ 최대 (y + l)
3. mid에서 모든 정사각형의 아래 면적 합산
4. 합 < target → Y 올림 (lo = mid)
5. 합 >= target → Y 내림 (hi = mid)
6. hi - lo가 충분히 작아지면 종료
```

---

## 코드

→ [Solution.java](./Solution.java)

---

## 복잡도

- 시간: O(n × log(범위 / 정밀도))
  - Binary Search 반복 × 정사각형 순회
- 공간: O(1)

---

## 다른 접근: Sweep Line

Binary Search는 매번 모든 정사각형을 순회함.

Sweep Line 기법을 쓰면:
- 정사각형의 시작/끝 이벤트를 정렬
- 한 번 쭉 훑으면서 면적 누적
- 시간복잡도: O(n log n)

더 효율적이지만 구현이 복잡함. Binary Search도 충분히 좋은 해법.

---

## 관련 문제

- 875: Koko Eating Bananas - 조건 만족 최솟값
- 1011: Capacity To Ship Packages - 조건 만족 최솟값
- 4: Median of Two Sorted Arrays - 이분 탐색 응용
